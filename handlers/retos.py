from telegram import Update
from telegram.ext import ContextTypes
from db import get_current_challenge, set_challenge, clear_challenge
import os
from datetime import datetime

# Retos predefinidos con validaciones string-based
WEEKLY_CHALLENGES = [
    {
        "id": 1,
        "title": "Documental Latinoamericano",
        "description": "Recomienda un documental latinoamericano anterior al a√±o 2000",
        "hashtag": "#recomendaci√≥n",
        "bonus_points": 10,
        "validation_keywords": ["argentina", "m√©xico", "brasil", "chile", "colombia", "per√∫", "venezuela", "bolivia", "ecuador", "uruguay", "paraguay"],
        "validation_type": "country_keywords"
    },
    {
        "id": 2,
        "title": "Cine de Terror Cl√°sico",
        "description": "Rese√±a una pel√≠cula de terror de los a√±os 70-80",
        "hashtag": "#rese√±a",
        "bonus_points": 15,
        "validation_keywords": ["70", "80", "1970", "1980", "terror", "horror"],
        "validation_type": "decade_genre"
    },
    {
        "id": 3,
        "title": "Director Europeo",
        "description": "Cr√≠tica de una pel√≠cula de directores europeos ic√≥nicos",
        "hashtag": "#cr√≠tica",
        "bonus_points": 12,
        "validation_keywords": ["bergman", "fellini", "tarkovsky", "godard", "truffaut", "antonioni", "bu√±uel"],
        "validation_type": "director_keywords"
    },
    {
        "id": 4,
        "title": "Cine Independiente",
        "description": "Aporta informaci√≥n sobre cine independiente o bajo presupuesto",
        "hashtag": "#aporte",
        "bonus_points": 8,
        "validation_keywords": ["independiente", "indie", "bajo presupuesto", "experimental"],
        "validation_type": "genre_keywords"
    }
]

def get_weekly_challenge():
    """Obtiene el reto de la semana basado en n√∫mero de semana del a√±o"""
    week_number = datetime.now().isocalendar()[1]
    challenge_index = (week_number - 1) % len(WEEKLY_CHALLENGES)
    return WEEKLY_CHALLENGES[challenge_index]

def validate_challenge_submission(challenge, text):
    """Valida si un mensaje cumple con los requisitos del reto"""
    text_lower = text.lower()
    
    if challenge["validation_type"] == "country_keywords":
        return any(keyword in text_lower for keyword in challenge["validation_keywords"])
    
    elif challenge["validation_type"] == "decade_genre":
        has_decade = any(decade in text_lower for decade in ["70", "80", "1970", "1980"])
        has_genre = any(genre in text_lower for genre in ["terror", "horror"])
        return has_decade or has_genre
    
    elif challenge["validation_type"] == "director_keywords":
        return any(director in text_lower for director in challenge["validation_keywords"])
    
    elif challenge["validation_type"] == "genre_keywords":
        return any(keyword in text_lower for keyword in challenge["validation_keywords"])
    
    return False

async def cmd_reto(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Muestra el reto actual de la semana"""
    try:
        # Intentar obtener reto personalizado de la DB
        current_challenge = get_current_challenge()
        
        if current_challenge:
            # Reto personalizado desde DB
            mensaje = (
                f"üéØ **Reto Especial**\n\n"
                f"üìΩÔ∏è {current_challenge}\n\n"
                f"üí∞ **Recompensa**: Puntos adicionales seg√∫n hashtag utilizado\n"
                f"‚è∞ **V√°lido**: Hasta que se establezca un nuevo reto\n\n"
                f"¬°Participa y demuestra tu conocimiento cin√©filo!"
            )
        else:
            # Reto autom√°tico semanal
            challenge = get_weekly_challenge()
            mensaje = (
                f"üéØ **Reto de la Semana #{datetime.now().isocalendar()[1]}**\n\n"
                f"üìΩÔ∏è **{challenge['title']}**\n"
                f"{challenge['description']}\n\n"
                f"üí∞ **Recompensa**: +{challenge['bonus_points']} puntos adicionales\n"
                f"üè∑Ô∏è **Usa el hashtag**: {challenge['hashtag']}\n"
                f"‚è∞ **V√°lido hasta**: Pr√≥ximo lunes\n\n"
                f"üí° *Tip: El bot validar√° autom√°ticamente tu participaci√≥n*"
            )
        
        await update.message.reply_text(mensaje, parse_mode='Markdown')
        
    except Exception as e:
        print(f"[ERROR] Error en cmd_reto: {e}")
        await update.message.reply_text("‚ùå Error al obtener el reto actual. Int√©ntalo m√°s tarde.")

async def reto_job(context):
    """Job que se ejecuta semanalmente para anunciar el nuevo reto"""
    try:
        # Obtener chat_id desde job_data
        chat_id = context.job.data if hasattr(context.job, 'data') and context.job.data else None
        
        if not chat_id:
            print("[ERROR] No hay chat_id configurado para reto autom√°tico")
            return
        
        # Obtener reto de la semana
        challenge = get_weekly_challenge()
        
        mensaje = (
            f"üö® **¬°NUEVO RETO SEMANAL!** üö®\n\n"
            f"üìΩÔ∏è **{challenge['title']}**\n"
            f"{challenge['description']}\n\n"
            f"üí∞ **Recompensa**: +{challenge['bonus_points']} puntos adicionales\n"
            f"üè∑Ô∏è **Hashtag requerido**: {challenge['hashtag']}\n"
            f"‚è∞ **Plazo**: 7 d√≠as desde ahora\n\n"
            f"¬°A demostrar sus conocimientos cin√©filos! üé¨\n"
            f"Usa `/reto` para ver los detalles cuando quieras."
        )
        
        # Enviar al chat configurado
        try:
            await context.bot.send_message(
                chat_id=chat_id,
                text=mensaje,
                parse_mode='Markdown'
            )
            print(f"[INFO] Reto semanal enviado a chat {chat_id}")
        except Exception as e:
            print(f"[ERROR] No se pudo enviar reto a chat {chat_id}: {e}")
                
    except Exception as e:
        print(f"[ERROR] Error en reto_job: {e}")

async def cmd_nuevo_reto(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando para que administradores establezcan retos personalizados"""
    # IDs de administradores desde variables de entorno
    ADMIN_IDS = [int(x) for x in os.environ.get("ADMIN_IDS", "").split(",") if x.strip()]
    
    if not ADMIN_IDS or update.effective_user.id not in ADMIN_IDS:
        await update.message.reply_text("‚ùå Solo administradores pueden usar este comando")
        return
    
    if not context.args:
        await update.message.reply_text(
            "‚ùå **Uso:** `/nuevoreto <descripci√≥n del reto>`\n\n"
            "**Ejemplo:**\n"
            "`/nuevoreto Recomienda una pel√≠cula de Akira Kurosawa`\n\n"
            "**Para limpiar reto actual:**\n"
            "`/nuevoreto limpiar`",
            parse_mode='Markdown'
        )
        return
    
    reto_text = " ".join(context.args)
    
    # Comando especial para limpiar
    if reto_text.lower() == "limpiar":
        try:
            clear_challenge()
            await update.message.reply_text("‚úÖ **Reto personalizado eliminado**\nAhora se usar√°n los retos semanales autom√°ticos")
            return
        except Exception as e:
            print(f"[ERROR] Error limpiando reto: {e}")
            await update.message.reply_text("‚ùå Error al limpiar el reto")
            return
    
    try:
        set_challenge(reto_text)
        await update.message.reply_text(
            f"‚úÖ **Nuevo reto establecido:**\n\n"
            f"üìΩÔ∏è {reto_text}\n\n"
            f"Los usuarios pueden verlo con `/reto`",
            parse_mode='Markdown'
        )
        
        print(f"[INFO] Reto personalizado establecido por admin {update.effective_user.id}")
        
    except Exception as e:
        print(f"[ERROR] Error en cmd_nuevo_reto: {e}")
        await update.message.reply_text("‚ùå Error al establecer el reto")
